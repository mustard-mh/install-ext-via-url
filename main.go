package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path"
	"strconv"
	"strings"
	"sync"
	"time"

	"gopkg.in/yaml.v2"
)

const DefaultVsxUrl = "https://open-vsx.org"
const Code = "/ide/bin/gitpod-code"

func main() {
	installExtensions()
}

func installExtensions() {
	repoRoot := os.Getenv("GITPOD_REPO_ROOT")
	yamlContent, err := os.ReadFile(path.Join(repoRoot, ".gitpod.yml"))
	if err != nil {
		fmt.Println(err)
		return
	}

	config := GitpodConfig{}
	err = yaml.Unmarshal(yamlContent, &config)
	if err != nil {
		fmt.Println("Cannot parse .gitpod.yml file")
		return
	}
	if config.Vscode == nil {
		fmt.Println("no extensions requeired")
		return
	}
	extensions := config.Vscode.Extensions

	args := []string{"--do-not-sync", "--server-data-dir", "/workspace/.vscode-remote"}

	var wg sync.WaitGroup
	var extensionsMu sync.Mutex
	for _, extId := range extensions {
		if strings.HasPrefix(extId, "http") {
			continue
		}
		wg.Add(1)
		go func(id string) {
			name, version := getNameNVersion(id)
			extUrl, err := resolveFromOpenVSX(DefaultVsxUrl, name, version)
			if err != nil {
				fmt.Println("Parse extension id to url failed", id, err)
				return
			}
			defer wg.Done()
			location, err := downloadExtension(extUrl)
			if err != nil {
				fmt.Println("Download extension failed", err)
				return
			}
			extensionsMu.Lock()
			args = append(args, "--install-extension", location)
			fmt.Printf("converted %s => %s\n", id, location)
			extensionsMu.Unlock()
		}(extId)
	}

	wg.Wait()

	fmt.Printf("\n\n%s %s\n---------------------\n\n", Code, strings.Join(args, " "))
	cmd := exec.Command(Code, args...)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		fmt.Println("Install extensions failed", err)
	} else {
		fmt.Println("Install extensions success")
	}
}

func resolveFromOpenVSX(vsxUrl string, name string, version string) (string, error) {
	url, err := url.Parse(vsxUrl)
	if err != nil {
		return "", err
	}
	url.Path = "/api/-/query"
	data := map[string]string{
		"extensionId": name,
	}
	if version != "" {
		data["extensionVersion"] = version
	}
	b, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	resp, err := http.Post(url.String(), "application/json", bytes.NewBuffer(b))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", errors.New("Failed with statusCode: " + strconv.Itoa(resp.StatusCode))
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	decodeBody := AutoGenerated{}
	err = json.Unmarshal(body, &decodeBody)
	if err != nil {
		return "", err
	}
	if len(decodeBody.Extensions) != 1 {
		return "", errors.New("extension not exist")
	}
	return decodeBody.Extensions[0].Files.Download, nil
}

func downloadExtension(url string) (location string, err error) {
	client := &http.Client{
		Timeout: 20 * time.Second,
	}
	resp, err := client.Get(url)
	if err != nil {
		return
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		err = errors.New("Failed to download extension: " + http.StatusText(resp.StatusCode))
		return
	}
	out, err := os.CreateTemp("", "vsix*.vsix")
	if err != nil {
		err = errors.New("Failed to create tmp vsix file: " + err.Error())
		return
	}
	defer out.Close()
	if _, err = io.Copy(out, resp.Body); err != nil {
		err = errors.New("Failed to resolve body stream: " + err.Error())
		return
	}
	location = out.Name()
	return
}

func getNameNVersion(id string) (string, string) {
	arr := strings.Split(id, "@")
	if len(arr) == 2 {
		return arr[0], arr[1]
	}
	return arr[0], ""
}

type AutoGenerated struct {
	Extensions []struct {
		Files struct {
			Download string `json:"download"`
		} `json:"files"`
	} `json:"extensions"`
}

type GitpodConfig struct {

	// Configure VS Code integration
	Vscode *Vscode `yaml:"vscode,omitempty"`
}

type Vscode struct {

	// List of extensions which should be installed for users of this workspace. The identifier of an extension is always '${publisher}.${name}'. For example: 'vscode.csharp'.
	Extensions []string `yaml:"extensions,omitempty"`
}
